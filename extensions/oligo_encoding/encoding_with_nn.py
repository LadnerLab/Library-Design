#!/usr/bin/env python3
import h2o        # For running models
import argparse   # for parsing command-line args
import pandas     # reading csv
import io         # for encoding strings as files
import subprocess # for calling the oligo encoding script
from timeit import default_timer as timer
import multiprocessing as mp

def main():
    arg_parser = argparse.ArgumentParser( description = "Use h2o to select encodings for oligos." )  

    arg_parser.add_argument( '-m', '--model', help = "Trained model that ill be used to predict bindings" )
    arg_parser.add_argument( '-r', '--ratio_file', help = "File containing output produced by oligo_encoding script." )
    arg_parser.add_argument( '-n', '--nn_subset_size', help = "The nn_subset_size number of encodings will be output that "
                                                              "have the smallest nn deviation",
                             default = 3, type = int
                           )
    arg_parser.add_argument( '-o', '--out_file', help = "File to write final encodings out to." )
    arg_parser.add_argument( '-s', '--sequences', help = "File to read sequences generated by the oligo_encoding script" )
    arg_parser.add_argument( '-i', '--input', help = "Input file containing name,seq pairs, the maximum line length is 128" )
    arg_parser.add_argument( '-c', '--cores', help = "Number of cores to use in the oligo_encoding script, default is 2, "
                                                     "as 2 generally has the best performance",
                             type = int,
                             default = 2
                           )
    arg_parser.add_argument( '--subsample', default = 10000, type = int,
                             help = "Number of randomly generated encodings to subsample" )

    arg_parser.add_argument( '--gc_target', type = float, default = 0.55, help = "Target gc ratio for generated seqs"
                             "The first subsample number of encodings to take will be those with minimum absolute value "
                             "difference from gc_target."
                           )
    arg_parser.add_argument( '-p', '--probability_file', help = "probability_file: lines must be formatted as {letter},"
                                                                "{nucleotides,3},{weighting},{index}. "
                                                                "The weightings do not need to sum to 1. Codon indices must range from 0 to 63.\n"
                           );
    arg_parser.add_argument( '-t', '--trials', type = int, default = 10000, help = "Number of trials to perform. For each sequence in sequences, trials number of "
                                                                       "candidate encodings will be created."
                           )
    arg_parser.add_argument( '--read_per_loop', type = int, default = 10, help = "Number of lines from the output seq and ratio files to read at a time, "
                                                                                 "the higher this parameter is the more memory will be used by h2o."
                           )
    arg_parser.add_argument( '--adapter', type = str, default = "CCTATACTTCCAAGGCGCA|GGTGACTCTCTGTCTTGGC", help = "Adapter to add to output encoded sequences. In the form {prefix}|{suffix}" )

    args = arg_parser.parse_args()

    if args.input:
        generate_oligos( args )
    if ( not args.input ) and args.subsample:
        print( "WARNING: Input file was not provided, but subsample argument was. "
               "This means that you are providing a file containing already-encoded sequences. "
               "In order to achieve best results, you must ensure that the 'subsample' argument "
               "is set to however many encodings were generated for each sequences."
             )

    h2o.init()

    loaded_model = h2o.load_model( args.model )

    best_encodings           = pandas.DataFrame()

    generated_sequences = open( args.sequences,  'r' )
    ratio_file          = open( args.ratio_file, 'r' )
    out_file            = open( args.out_file,   'w' )

    num_to_read   = args.read_per_loop
    current_seq   = read_seq( generated_sequences,    args.subsample, num_to_read )
    current_ratio = read_and_label_ratio( ratio_file, args.subsample, num_to_read )

    while not current_seq is None and not current_ratio is None:
        predictions = loaded_model.predict( h2o.H2OFrame( current_ratio ) )

        current_seq[ 'predicted' ]     = predictions.as_data_frame()
        current_seq[ 'predicted_dev' ] = predictions.abs().as_data_frame()

        best_encodings = get_n_best_encodings( current_seq, 'AA Peptide', args.nn_subset_size, args.cores )

        best_encodings[ "Nucleotide Encoding w/ Adapters" ] = add_adapters( best_encodings[ "Nucleotide Encoding" ], args.adapter )

        write_output( best_encodings, out_file )

        current_seq   = read_seq( generated_sequences,    args.subsample, num_to_read )
        current_ratio = read_and_label_ratio( ratio_file, args.subsample, num_to_read )

def generate_oligos( args ):
    subprocess.call( "./main -i %s -s %s -r %s -p %s -n %d -g %f -t %d -c %d" %
                     ( args.input, args.sequences, args.ratio_file, args.probability_file, args.subsample, args.gc_target, args.trials, args.cores ),
                     shell = True
                   )
def read_seq( open_file, subsample, num_to_read ):
    io_data = read_n_lines_from_file( open_file, num_to_read * subsample )

    if io_data:
        return read_seq_file( io_data )
    return None

def read_and_label_ratio( open_file, subsample, num_to_read ):
    io_data = read_n_lines_from_file( open_file, num_to_read * subsample )
    if io_data:
        return read_ratio_and_label( io_data )
    return None

def read_n_lines_from_file( open_file, n ):
    seq_str = ""
    for cur in range( n ):
        seq_str += open_file.readline()
    if seq_str:
        return io.StringIO( seq_str )
    return None
    
def write_output( encodings, outfile ):
    encodings.to_csv( outfile, index = False,
                      header = outfile.tell() == 0
                    )


def get_n_best_encodings( seqs_dataframe, key, n, cores ):
    pool = mp.Pool( cores - 1 )
    args = list()

    unique_seqs = get_unique_seqs( seqs_dataframe, key )
    for index, seq in enumerate( unique_seqs ):
        args.append( ( seqs_dataframe, 'AA Peptide', n, seq ) )

    start = timer()
    result = pool.map( get_n_best_encodings_parr,
                       args
    )

    pool.close()
    pool.join()
    results_df = pandas.concat( result )
    end = timer()

    print( "Time to generate results: %f" % ( end - start ) )
    return results_df 

def get_n_best_encodings_parr( arg ):
    seqs_dataframe = arg[ 0 ]
    key            = arg[ 1 ]
    n              = arg[ 2 ]
    seq_id         = arg[ 3 ]
    total_start = timer()
    out_frame = pandas.DataFrame()

    desired = seqs_dataframe[ key ] == seq_id 
    relevant_data = seqs_dataframe[ desired ]
    unique_seqs = relevant_data.drop_duplicates( subset = 'Nucleotide Encoding' )
    print( len( unique_seqs ) )
    sorted_data   = unique_seqs.sort_values( 'predicted_dev' )
    out_frame     = out_frame.append( sorted_data.iloc[ 0:n ] )

    total_end = timer()

    return out_frame

def get_unique_seqs( dataframe, key ):
    return set( dataframe[ key ] )
def read_ratio_and_label( filename ):
    parsed_file = pandas.read_csv( filename )

    parsed_file.columns = [ "C" + str( item ) for item in range( 1442,1530 ) ]

    return parsed_file

def read_seq_file( filename ):
    parsed_file = pandas.read_csv( filename )
    parsed_file.columns = [ "Seq ID", "AA Peptide", "Nucleotide Encoding",
                            "GC Ratio", "GC Dev (abs)"
                          ]

    return parsed_file

def add_adapters( data, adapter ):
    prefix, suffix = adapter.split( '|' )
    out_items = list()

    for item in data:
        out_items.append( prefix + item + suffix )
    return out_items
    

if __name__ == '__main__':
    main()
