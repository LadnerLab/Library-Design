#!/usr/bin/env python3

# By Jason Ladner

# Used to select final encodings for PepSeq libraries

import argparse
import itertools as it
import inout as io               #Available at https://github.com/jtladner/Modules
import fastatools as ft          #Available at https://github.com/jtladner/Modules
import kmertools as kt          #Available at https://github.com/jtladner/Modules

from collections import defaultdict

def main():

    #To parse command line
    p = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    
    p.add_argument('-x', '--extraEnc', help='Optional file that is of the same type provided with the -e flag, but including a greater number of encodings per peptide.')
    p.add_argument('-t', '--truncLen', type=int, default=40, help='Length of truncated encoding to test for uniqueness.')

    reqArgs = p.add_argument_group('required arguments')
    reqArgs.add_argument('-e', '--enc', help='CSV-formatted file generated by encoding_with_nn.py.', required=True)
    reqArgs.add_argument('-o', '--out', help='Base name for output files.', required=True)

    args = p.parse_args()
    
    # Read in encodings and select the top scoring encoding for each peptide
    topEnc, topEncAdapt, encLD, truncLD = readEncodings(args.enc, args)
    topEncTrunc = {v[:args.truncLen]:k for k,v in topEnc.items()}
    
    # Generate dictionary with truncated encodings as keys and lists of codenames as values
    topTruncD = defaultdict(list)
    for k,v in topEnc.items():
        topTruncD[v[:args.truncLen]].append((k, v, topEncAdapt[k]))
    
    # Check to see if all truncated encodings are unique and, if they are, then generate output files
    if len(topTruncD) == len(topEnc):
        print(f"No encoding conflicts. Writing output files.\n")
        write_output_fastas(topEnc, topEncAdapt, args)
    
    # If there are some peptides with identical encodings when truncated
    elif len(topTruncD) < len(topEnc):

        # Remove redundant encodings from the output fasta files
        for k, v in topTruncD.items():
            if len(v) > 1:
                del(topEncTrunc[topEnc[v[0][0]][:args.truncLen]])
                for eachV in v:
                    del(topEnc[eachV[0]])
                    del(topEncAdapt[eachV[0]])
                
        
        # Remove unique encodings from the topTruncD dictionary
        for v in topEnc.values():
            del(topTruncD[v[:args.truncLen]])

        print(f"\nAttempting to resolve {len(topTruncD)} conflicts with initial options.\n")


        to_deconv = []

        for seq, nameL in topTruncD.items():
            # Check for universally unique encodings
            univUniqL = [checkForUnivUniq(encLD[n], truncLD) for n in [y[0] for y in nameL]]
            numUnivUniq = sum([1 for x in univUniqL if x])
    
            # If all peptides or all except one have universally unique encoding options
            if numUnivUniq >= (len(nameL)-1):
                for i, info in enumerate(nameL):
                    name = info[0]
                    if univUniqL[i]:
                        newFull = univUniqL[i][1]
                        newAdapt = univUniqL[i][2]
                    else:
                        newFull  = info[1]
                        newAdapt = info[2]
                        
                    topEnc[name] = newFull
                    topEncAdapt[name] = newAdapt
                    topEncTrunc[newFull[:40]] = name

            # If more than one peptide lacks a universally unique encoding option
            else:
                newNameL = []
                # First, add all peptides with universally unique options to the output dictionaries
                for i, info in enumerate(nameL):
                    name = info[0]
                    if univUniqL[i]:
                        newFull = univUniqL[i][1]
                        newAdapt = univUniqL[i][2]
                        topEnc[name] = newFull
                        topEncAdapt[name] = newAdapt
                        topEncTrunc[newFull[:40]] = name
                    else:
                        newNameL.append(info)

                        
                #Add info to a list to be returned to later
                to_deconv.append(newNameL)

        to_indepth = []
        for newNameL in to_deconv:
            forFurther = searchForUniqCombo(newNameL, encLD, topEnc, topEncTrunc, topEncAdapt)
            to_indepth += forFurther

        if not to_indepth:
            if len(topEnc) == len(topEncAdapt):
                print(f"Was able to resolve all conflicts with initial encodings. Now writing output files.\n")
                write_output_fastas(topEnc, topEncAdapt, args)
            else:
                print(f"There is a problem.\n")
            
        elif args.extraEnc:
            print(f"\nMoving to extra encodings to resolve {len(to_indepth)} conflicts.\n")
            
            # Make dict with keys for the target peptides, to extract info from the extra encodings file
            targets = {}
            for group in to_indepth:
                for every in group:
                    targets[every[0]] = ""

            encLD = defaultdict(list)
            truncLD = defaultdict(list)
            
            # Read in encodings for the remaining peptides with conflicts
            with open(args.extraEnc, "r") as fin:
                next(fin)
                for line in fin:
                    cols = line.rstrip("\n").split(",")
                    seqID = cols[0]
                    
                    simpN = "_".join(seqID.split("_")[:2])
                    if simpN in targets:        
                        encSeq = cols[2]
                        encSeqAdapt = cols[7]
                        encLD[simpN].append((encSeq[:args.truncLen], encSeq, encSeqAdapt))
                        truncLD[encSeq[:args.truncLen]].append(simpN)

            stillProb = []
            for newNameL in to_indepth:
                forFurther = searchForUniqCombo(newNameL, encLD, topEnc, topEncTrunc, topEncAdapt)
                stillProb += forFurther
            
            if not stillProb:
                if len(topEnc) == len(topEncAdapt):
                    print(f"Was able to resolve all conflicts using additional encodings. Now writing output files with {len(topEnc)} sequences.")
                    write_output_fastas(topEnc, topEncAdapt, args)

                else:
                    print(f"There is a problem.")
            
            else:
                print(f"Not able to resolve {len(stillProb)} conflicts.")
        
    else:
        print(f"Something is wrong. There are more keys in the topTruncD ({len(topTruncD)} than in in the topEnc ({len(topEnc)})")
    
###-----------------End of main()--------------------------->>>

def write_output_fastas(encD, adaptD, args):
    ft.write_fasta_dict(encD, f"{args.out}.fna")
    ft.write_fasta_dict(adaptD, f"{args.out}_wAdapters.fna")

def readEncodings(encFile, args):

    encLD = defaultdict(list)
    truncLD = defaultdict(list)
    
    topEnc = {}
    topEncAdapt = {}
    topScore = {}
    
    with open(encFile, "r") as fin:
        next(fin)
        for line in fin:

            cols = line.rstrip("\n").split(",")

            seqID = cols[0]
            simpN = "_".join(seqID.split("_")[:2])
            encSeq = cols[2]
            encSeqAdapt = cols[7]
            score = float(cols[6])
            
            # Check to see if this is the best scoring ecoding for this peptide
            if simpN not in topEnc:
                topEnc[simpN] = encSeq
                topEncAdapt[simpN] = encSeqAdapt
                topScore[simpN] = score
            elif score < topScore[simpN]:
                topEnc[simpN] = encSeq
                topEncAdapt[simpN] = encSeqAdapt
                topScore[simpN] = score
                
            
            encLD[simpN].append((encSeq[:args.truncLen], encSeq, encSeqAdapt))
            truncLD[encSeq[:args.truncLen]].append(simpN)

    return topEnc, topEncAdapt, encLD, truncLD

def checkForUnivUniq(options, seqNameLD):
    for each in options:
        if len(set(seqNameLD[each[0]])) == 1:
            return each

def searchForUniqCombo(newNameL, encLD, outD, outD_trunc, outAdapt):
    forFurther = []
    combos = []
    foundSolution = 0
    for i in range(1, len(encLD[newNameL[0][0]])):
        indexOptions = list(range(i+1))
        indexCombos = list(it.product(indexOptions, repeat=len(newNameL)))
        for thisOne in indexCombos:
            truncList = [encLD[newNameL[pos][0]][j][0] for pos, j in enumerate(thisOne)]
            # If all truncated peptides are unique
            if len(truncList)==len(set(truncList)):
                # If none of these trunc peptides are already in the design
                if len(truncList)==sum([1 for tp in truncList if tp not in outD_trunc]):
                    foundSolution=thisOne

                    for k, encNum in enumerate(thisOne):
                        name = newNameL[k][0]
                        newFull = encLD[name][encNum][1]
                        newAdapt = encLD[name][encNum][2]
                        outD[name] = newFull
                        outAdapt[name] = newAdapt
                        outD_trunc[newFull[:40]] = name
                    break
        if foundSolution:
            #print("Good", foundSolution, len(newNameL))
            break
    
    if not foundSolution:
        forFurther.append(newNameL)
        names = ",".join([x[0] for x in newNameL])
        print(f"No solution for {names} with initial encodings.")
    
    return forFurther


###------------->>>

if __name__ == "__main__":
    main()
